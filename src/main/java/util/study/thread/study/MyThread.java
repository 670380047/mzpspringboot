package util.study.thread.study;/**
 * @version: java version 1.7+
 * @Author : mzp
 * @Time : 2020/6/1 10:50
 * @File : AThread
 * @Software: IntelliJ IDEA 2019.3.15
 */

/**
 *  创建线程的方式一共有4中：
 *          1.继承Thread类、  --》PrimeThreadTest类中
 *          2.实现Runnable接口、 --》PrimeRunTest类中
 *          3.实现Callable接口、 --》TestCallable类中
 *          4.线程池、      --》TestThreadPool类中（包含批量处理数据的demo）   --》TestSimpleDateFormat类中
 *
 * 1.什么是程序？为了完成某项特定的任务，使用某种语言，编写了一组指令的集合。
 * 2.什么是进程？就是一个正在进行的程序
 * 3.什么是线程？在一个进程中，执行一套功能流程，成为线程。
 *            在一个进程中，执行的多套工能流程，成为多线程。
 * 4.抢占式策略系统：系统会分配给每个执行任务的线程一个很小的时间段用于执行任务，当该时间段用完后，
 *            系统会自动的剥夺其cpu的使用权，交给其他线程去使用。
 *
 *            java中的都是抢占式的，谁抢到就是谁的（对高优先级，使用优先调度的抢占式）。
 *            与之对应的还要一个“时间片式”:（先进先出队列）这种就是线层等待cpu去平均分配时间片。
 *      4.1 以单核CPU为例，单线程和多线程基本没有区别，甚至多线程更慢（把一个任务分成多块，多了cpu切换时间）
 *      4.2 多线程的优点：提高计算机系统对CPU的利用率。
 * 5. JVM本身是多线程的。如：main方法称为主线程，gc 也在并发执行。
 *      创建线程的方式一共有4中：继承Thread类、实现Runnable接口、实现Callable接口、线程池
 * 6. 创建线程的方式一： --PrimeThreadTest类中
 *      6.1 声明一个类继承Thread类
 *      6.2 重写run方法，同时编写线程执行体，也就是run方法的方法体
 *      6.3 创建该类的实例
 *      6.4 用该实例调用start()方法启动线程，默认执行run()方法
 * 7. 创建线程的方式二： --PrimeRunTest类中
 *      7.1 声明一个类，实现Runnable接口
 *      7.2 实现接口中的run()方法，同时编写线程执行体
 *      7.3 创建该实现类的实例
 *      7.4 创建Thread类的实例，将上一步中实现类的实例作为参数，传递给Thread的构造器
 *      7.5 通过Thread类的实例，来调用start()方法，默认执行run()方法
 * 8. 线程常用方法： --WindowTest类中
 *      8.1 currentThread(): 获取当前执行线程
 *      8.2 getName(): 获取线程名称
 *      8.3 start(): 启动线程。通知“线程规划器”，该线程处于就绪状态，等待CPU调用
 *      8.4 setName(String name): 给线程设置名字
 * 9. 继承Thread和实现Runnable接口的区别：--WindowTest类中  和   TicketTest类中
 *      9.1 继承Thread类：书写起来方便
 *      9.2 实现Runnable接口：（这种方式更推荐）
 *          9.2.1 避免了单继承的局限性，很好的利用了接口的多实现
 *          9.2.3 多个线程可以共享同一个接口子类的对象，非常适合多线程来处理同一份资源
 * 10. 结束线程:
 *             10.1 通知方式：线程体中通常写的都是一些循环语句，用来循环执行。（如果是单条语句，也没必要写一个线程），
 *              因此控制住了循环，就相当于控制住了线程，即通知方式。 使用这种方式。 --EndThreadTest类中
 *    （已过时）10.2 已过时：Thread.stop():  立即停止该线程。释放所有资源。（不管业务逻辑跑了多少，都立刻强制停止），不建议使用。
 * 11. 线程控制：--ControllerRunTest类中
 *      11.1 sleep(long millis) : 是一个静态方法，使当前线程进入睡眠（阻塞）状态。睡眠也是阻塞。（常用）
 *      11.2 join() / join(long mills): 是一个实例方法。作用同sleep一样，使线程进入阻塞状态。
 *            11.2.1  t1.join()也就是告诉t1线程的调用者（是t1所在的线程，并不是t1线程本身。比如t1在main线程里被使用，那么此时暂停的就是main线程。），t1要执行完毕，调用者才能继续。
 *                  重点重点：而且此时t1线程中操作的数据结果对后续线程可见了。即t1已经指向完，并且更新主存了，然后唤醒后续的线程调用者可以用到我的结果继续跑了
 *            11.2.2  t1.join(100) 告诉当前线程（是t1所在的线程，并不是t1线程本身。比如t1在main线程里被使用，那么此时暂停的就是main线程。），我t1在这里要执行100毫秒，100毫秒结束后，你再执行
 *                  （如果100毫秒后，t1没有执行完毕，那么t1和所在线程还会继续“抢占式”争夺cpu）
 *      11.3 interrupt(): 是一个实例方法。用来唤醒“一次”阻塞的线程。（如果run方法中是循环睡眠的话，只会唤醒一次。）
 *      11.4 isAlive() : 是一个实例方法。用来判断线程是否存活状态。阻塞（睡眠）也是活跃状态。只要不是死亡
 *      11.5 yield() : 是一个静态方法。线程让步：暂缓当前线程的执行。（抢到资源之后，放弃资源，重新再抢）
 *      11.6 interrupt(): 发个通知，让线程中断。--InterruptTest类中
 * 12. 线程优先级：1--10（1最低，10最高。默认是5） --PriorityRunnableTest类中
 *          12.1 setPriority(int newPriority) 设置优先级
 *              MIN_PRIORITY: 1
 *              NORM_PRIORITY: 5
 *              MAX_PRIORITY: 10
 *          12.2 getPriority() 获取优先级
 *          优先级高，比一定会先执行，只不过是更多的获取cpu的资源
 * 13. 线程的生命周期：--ControllerRunTestJoin类中
 *           操作系统中：【新建、就绪、运行、等待、死亡】        java中是【新建、可运行、被阻塞、等待、计时等待、被终止】
 *          新建 ---start()---> 就绪（可运行） ---获取到了cpu--> 运行 --run()执行完/Error/Exception没处理--> 结束（死亡）
 *
 *          运行 ---sleep()/join()---> 阻塞 ----时间到/interrupt() ---> 就绪     --ControllerRunTest类中
 *
 *          运行 ----失去cpu资源/yield()---> 就绪
 * 14. 线程同步： --SyncRunTest类中
 *   14.1.同步代码块
 *          synchronized(同步监视器)｛
 *              // 需要访问的共享数据
 *          ｝
 *        其中的“同步监视器”:俗称“锁”。可以使用任意对象充当，但是必须确保多个线程持有同一把锁（同一个对象）。
 *   14.2.同步方法:
 *          在返回值前面加上synchronized关键字。-----隐式的锁：this（非静态方法）  类.class（静态方法）
 *          public synchronized void show(){
 *              // 需要访问的共享数据
 *          }
 *   14.3.同步锁：
 *      14.3.1 创建一个ReentrantLock锁的实例。
 *          Lock lock = new ReentrantLock();
 *      14.3.2 手动加锁
 *          lock.lock();
 *      14.3.3 手动解锁。解锁最好放在finally中
 *          lock.unlock();
 * 15. 释放锁的操作：
 *      15.1 当前线程的同步方法、同步代码快执行结束
 *      15.2 当前线程在同步代码快、同步方法中遇到break、return终止了该代码块、该方法的继续执行(同第一种一样，“执行结束”了)
 *      15.3 当前线程在同步代码快、同步方法中出现了“未处理”的Error或Exception，导致异常结束。
 *      15.4 当前线程在同步代码快、同步方法执行了线程对象的wait()方法，当前线程就会暂停、并释放锁。
 * 16. 不会释放锁的操作：
 *      16.1 Thread.sleep()、Thread.yield()方法暂停当前线程的执行，但都不会释放锁。
 *      16.2 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器）
 *             ！！！注意：应尽量避免使用suspend()和resume()来控制线程。而且这俩方法已过期
 * 17. 线程通信（交互）： --WaitNotifyRunTest类中
 *          当多个线程在完成某些任务时，多个线程之间也需要一定通信，及线程通信。
 *
 *      17.1. wait(): 当前线程进入等待状态。wait()方法：等待的同时，释放锁。 被唤醒然后在取到锁之后，还是在当前这个位置执行的，不是从新执行临界区的代码
 *      17.2. notify()/notifyAll(): 唤醒一个/所有当前监视器下（锁）处于等待状态的线程。
 * 18. 生产者消费者场景：  --TestProducer类中
 * @Description:
 * @Author maozp3
 * @Date: 2020/6/1 9:49
 */
public class MyThread {
}
